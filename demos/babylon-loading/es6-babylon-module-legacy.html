<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Use Babylon as ES6 legacy module</title>
    <script src="../../babylonscene.js" type="module"></script>


    <style>
        babylon-scene {
            width: 300px;
            height: 300px;
        }
    </style>
</head>
<body>

<h1>Use Babylon as ES6 legacy module</h1>
<p>
    In this demo, both Babylon and the &lt;babylon-scene&gt;
    component are brought in as ES6 modules. This repo provides a <a href="https://doc.babylonjs.com/features/es6_support">legacy</a> version
    of Babylon.js. Because it's legacy and imports everything, Babylon.js is still added to the window.BABYLON variable.
    Therefore, to turn off the auto-detection behavior and use this legacy ES6 module, we explicitly set useglobalbabylon="false".
</p>

<p>
    Babylon.js is provided by the static method on the loaded application.
    <pre>
        import BaseApplication from '../../src/baseapplication.js';
        import * as Babylon from '@babylonjs/core/Legacy/legacy';

        export default class extends BaseApplication {
            static get Babylon() { return Babylon; }
    ...
    </pre>
</p>

<p>
    As Babylon.js uses bare module imports, a plain HTTP server will not be able to accommodate running Babylon.js this way.
    Instead, <a href="https://open-wc.org/developing/es-dev-server.html">Open WC's ES Dev Server</a> is a great solution.
    Alternately, the non-ES6 Babylon can be wrapped as an ES6 module by <a href="https://www.pika.dev/">Pika</a>. With that, a plain
    HTTP server will work, and only the import needs to change to the Pika generated import:

    <pre>
        import * as Babylon from '@babylonjs/core/Legacy/legacy';
    </pre>
</p>

<babylon-scene app="app-legacy-babylon.js" useglobalbabylon="false"></babylon-scene>
</body>
</html>
